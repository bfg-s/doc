<?phpnamespace Bfg\Doc\Core;use Bfg\Doc\Attributes\Doc;use Bfg\Doc\Attributes\DocClassName;use Bfg\Route\Attributes\RouteAttribute;use Illuminate\Broadcasting\InteractsWithSockets;use Illuminate\Filesystem\Filesystem;use Illuminate\Foundation\Events\Dispatchable;use Illuminate\Queue\SerializesModels;use Illuminate\Support\Collection;use Symfony\Component\Finder\SplFileInfo;/** * Class DataForGenerate * @package Bfg\Doc\Core * @property */class DataForGenerate{    /**     * @var Collection     */    public Collection $data;    /**     * DataForGenerate constructor.     * @param  Filesystem  $filesystem     * @param  ScanClasses  $scanClasses     */    public function __construct(        protected Filesystem $filesystem,        public ScanClasses $scanClasses    ) {        $this->data = $this->makeList($scanClasses->classes);    }    /**     * @param  Collection  $classes     * @return Collection     */    protected function makeList(Collection $classes): Collection    {        return $classes->map(function (array $data) {            $olds = $data['old_doc'] ? $this->rereadOldDoc($data['old_doc']) : [];            $inserts = $this->generateInsertDoc($data);            $doc_files = $this->readDocFiles($data);            $inserts = array_merge($inserts, $this->makeMixins($doc_files));            return [                'file' => $data['file'],                'class' => $data['class'],                'class_header' => $data['class_header'],                'doc_header' => $data['old_doc'],                'doc' => [                    'old' => $olds,                    'insert' => $inserts,                    'doc' => array_merge(array_diff($olds, $inserts), $inserts)                ],                'doc_files' => $doc_files            ];        });    }    /**     * @param  array  $data     * @return array     */    protected function makeMixins(array $data): array    {        $result = [];        foreach ($data as $namespace => $classes) {            foreach ($classes as $class => $lines) {                $result[] = "* @mixin \\" . ($namespace ? $namespace . "\\" : "") . $class;            }        }        return $result;    }    /**     * @param  array  $data     * @return array     */    protected function readDocFiles(array $data): array    {        $result = [];        $exploded = explode("\\", $data['class']);        $last_key = array_key_last($exploded);        $class_name = $exploded[$last_key];        unset($exploded[$last_key]);        $exploded = array_values($exploded);        if ($exploded) {            $class_namespace = implode("\\", $exploded);        } else {            $class_namespace = "";        }        foreach ($data['props'] as $var_name => $prop) {            if ($prop['doc_name']) {                $params = [                    'name' => ucfirst($var_name),                    'class' => $class_name,                    'namespace' => $class_namespace,                ];                $namespace = tag_replace($prop['doc_name']->namespace, $params);                $name = tag_replace($prop['doc_name']->name, $params);                if (!isset($result[$namespace][$name])) {                    $result[$namespace][$name] = [];                }                $result[$namespace][$name] = array_merge($result[$namespace][$name],                    $this->generate_data_props($prop, $var_name));            }        }        return $result;    }    /**     * @param  string  $old     * @return array     */    protected function rereadOldDoc(string $old): array    {        $lines = array_values(            array_diff(                array_map(                    'trim',                    explode("\n", $old)                ),                ['/**', '*', '*/'])        );        return count($lines) > 1 ? $lines : [];    }    /**     * @param  array  $data     * @return array     */    protected function generateInsertDoc(array $data): array    {        $result = [];        foreach ($data['props'] as $var_name => $prop) {            if (!$prop['doc_name']) {                $result = array_merge($result, $this->generate_data_props($prop, $var_name));            }        }        return $result;    }    /**     * @param  array  $prop     * @param $var_name     * @return array     */    protected function generate_data_props(array $prop, $var_name): array    {        $result = [];        if ($prop['value_type'] == 'array' && is_array($prop['value'])) {            foreach ($prop['value'] as $key => $value) {                $result[] = $this->make_template($this->parse_template($prop['doc_template'], [                    'name' => $var_name,                    'key' => $key,                    'value' => $value,                ]));            }        } else {            $result[] = $this->make_template($this->parse_template($prop['doc_template'], [                'type' => $prop['value_type'],                'value' => $prop['value'],            ]));        }        return $result;    }    /**     * @param  Doc  $doc     * @return string     */    protected function make_template(Doc $doc): string    {        return trim("* @{$doc->type} {$doc->var_type} {$doc->name} {$doc->description}");    }    /**     * @param  Doc  $doc     * @param  array  $props     * @return Doc     */    protected function parse_template(Doc $doc, array $props = []): Doc    {        $props = array_merge($props, []);        $new_doc = new Doc($doc->type, $doc->var_type, $doc->name, $doc->description);        $new_doc->var_type = (string) ($new_doc->var_type ? tag_replace($new_doc->var_type, $props) : "");        $new_doc->description = (string) ($new_doc->description ? tag_replace($new_doc->description, $props) : "");        $new_doc->name = $new_doc->name ? (string) tag_replace($new_doc->name, $props) : "";        $new_doc->type = $new_doc->type ? (string) tag_replace($new_doc->type, $props) : "";        return $new_doc;    }}